///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.30.1.6000 for 8051              20/Oct/2019  21:40:42
// Copyright 2004-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Components\stack\zcl\zcl_ezmode.c
//    Command line       =  
//        -f C:\Users\hhhho\AppData\Local\Temp\EW6912.tmp
//        (C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Components\stack\zcl\zcl_ezmode.c
//        -D SECURE=1 -D xNV_INIT -D xNV_RESTORE -D ZTOOL_P1 -D
//        LCD_SUPPORTED=FALSE -D MULTICAST_ENABLED=FALSE -D
//        FEATURE_SYSTEM_STATS -lC
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\RouterEB\List
//        -lA
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\RouterEB\List
//        --diag_suppress Pe001,Pa010 -o
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\RouterEB\Obj
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -f
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DRTR_NWK) -f
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
//        -f
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\Source\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\Source\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\hal\include\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\include\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\mt\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\osal\include\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\af\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\zcl\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\zmac\
//        -I
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
//        -Ohz --require_prototypes)
//    Locale             =  Chinese (Simplified)_CHN.936
//    List file          =  
//        C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Projects\zstack\Prj\SampleApp\CC2530DB\RouterEB\List\zcl_ezmode.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME zcl_ezmode

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// C:\Users\hhhho\Desktop\Z-Stack1.2.2a-spp-v001\Z-Stack1.2.2a-spp-v001\Components\stack\zcl\zcl_ezmode.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl_ezmode.c
//    3   Revised:        $Date: 2014-12-03 14:48:39 -0800 (Wed, 03 Dec 2014) $
//    4   Revision:       $Revision: 41325 $
//    5 
//    6   Description:    Zigbee Cluster Library - EZ Mode
//    7 
//    8 
//    9   Copyright 2013-2014 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 #include "ZComDef.h"
//   44 
//   45 #include "zcl.h"
//   46 #include "zcl_general.h"
//   47 #include "zcl_ezmode.h"
//   48 
//   49 #if !defined ( ZCL_STANDALONE )
//   50   #include "OSAL.h"
//   51   #include "zcl_ha.h"
//   52 #endif
//   53 
//   54 
//   55 #ifdef ZCL_EZMODE
//   56 
//   57 /*********************************************************************
//   58  * MACROS
//   59  */
//   60 
//   61 /*********************************************************************
//   62  * CONSTANTS
//   63  */
//   64 
//   65 /*********************************************************************
//   66  * TYPEDEFS
//   67  */
//   68 
//   69 /*********************************************************************
//   70  * LOCAL PROTOTYPES
//   71  */
//   72 static void zcl_SetEZModeError( uint8 errorCode );
//   73 static void zcl_SetEZModeState( zlcEZMode_State_t newState );
//   74 static void zcl_ProcessEZMode( void );
//   75 
//   76 
//   77 /*********************************************************************
//   78  * GLOBAL VARIABLES
//   79  */
//   80 
//   81 // internal EZ-Mode state machine
//   82 uint8  zclEZModeRegistered;
//   83 uint8  zclEZModeErr;
//   84 uint8  zclEZModeState;
//   85 uint8  zclEZModeOpener;
//   86 uint8  zclEZModeMatched;              // we were matched by a remote node
//   87 uint16 zclEZModeQueryRspNwkAddr;      // short address (on QueryRsp)
//   88 uint8  zclEZModeQueryRspEP;           // endpoint (on QueryRsp)
//   89 zclEZMode_RegisterData_t zclEZModeRegisterData; // registered once on init
//   90 zclEZMode_InvokeData_t   zclEZModeInvokeData; // user's configuration parameters
//   91                                               // what endpoint, initiator, etc.
//   92 
//   93 /*********************************************************************
//   94  * GLOBAL FUNCTIONS
//   95  */
//   96 
//   97 /*********************************************************************
//   98  * @fn      zcl_RegisterEZMode
//   99  *
//  100  * @brief   Called upon task initialation, to initialize EZ-Mode.
//  101  *
//  102  * @param   pData - task ID, App Callback routine, etc..
//  103  *
//  104  * @return  none
//  105  */
//  106 void zcl_RegisterEZMode( zclEZMode_RegisterData_t const *pData )
//  107 {
//  108   // make a copy of the data. Cannot fail.
//  109   zcl_memcpy( &zclEZModeRegisterData, (void *)pData,
//  110               sizeof(zclEZMode_RegisterData_t) );
//  111   zclEZModeRegistered = TRUE;
//  112 }
//  113 
//  114 /*********************************************************************
//  115  * @fn      zcl_InvokeEZMode
//  116  *
//  117  * @brief   Called to invoke EZ-Mode on an endpoint. This is a toggle
//  118  *          (will cancel if EZ-Mode currently enabled). Note: there is only 1
//  119  *          state machine. EZ-Mode can only be invoked on 1 endpoint at a time.
//  120  *
//  121  * @param   none
//  122  *
//  123  * @return  none
//  124  */
//  125 void zcl_InvokeEZMode( zclEZMode_InvokeData_t *pData )
//  126 {
//  127   // if not registered, do nothing
//  128   if(!zclEZModeRegistered)
//  129   {
//  130     return;
//  131   }
//  132 
//  133   // there is only 1 EZ-Mode state machine. If already in EZ-Mode, cancel it
//  134   if(zclEZModeState != EZMODE_STATE_READY)
//  135   {
//  136     zcl_SetEZModeError ( EZMODE_ERR_CANCELLED );
//  137     // needed to shut down timers, turn off joining, etc...
//  138     zcl_SetEZModeState ( EZMODE_STATE_FINISH );
//  139     return;
//  140   }
//  141 
//  142   // copy the data, so we remember which endpoint, etc...
//  143   zcl_memcpy( &zclEZModeInvokeData, pData, sizeof(zclEZMode_InvokeData_t) );
//  144 
//  145   // start with no error, and no QueryResponses in our list
//  146   zcl_SetEZModeError ( EZMODE_ERR_SUCCESS );
//  147   zclEZModeOpener = zclEZModeMatched = 0;
//  148 
//  149   // if already on network, just go to identify state
//  150   if ( zclEZModeInvokeData.onNetwork )
//  151   {
//  152     zcl_SetEZModeState( EZMODE_STATE_OPENER );
//  153   }
//  154 
//  155   // not already on network, form/join a network
//  156   else
//  157   {
//  158     zcl_SetEZModeState( EZMODE_STATE_JOINER );
//  159   }
//  160 
//  161   // start a total timeout for EZ_Mode (will cancel if not finished in this time)
//  162   zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID,
//  163                      zclEZModeRegisterData.timeoutEvt, EZMODE_TIME );
//  164 }
//  165 
//  166 /*********************************************************************
//  167  * @fn      zcl_EZModeAction
//  168  *
//  169  * @brief   Called when the application needs to inform EZ-Mode of some action
//  170  *          (now on the network, identify mode query, etc...)
//  171  *
//  172  * @param   action - which action has taken place
//  173  *          pData  - the data unique to the action
//  174  *
//  175  * @return  none
//  176  */
//  177 void zcl_EZModeAction(zclEzMode_Action_t action, zclEZMode_ActionData_t *pData)
//  178 {
//  179   ZDO_MatchDescRsp_t *pMatchDescRsp;
//  180   zAddrType_t dstAddr;
//  181 
//  182   // not in the EZ-Mode state machine, so do nothing
//  183   if( zclEZModeState == EZMODE_STATE_READY )
//  184     return;
//  185 
//  186   switch ( action )
//  187   {
//  188     case EZMODE_ACTION_PROCESS:
//  189       zcl_ProcessEZMode();  // process next state
//  190     break;
//  191 
//  192     case EZMODE_ACTION_NETWORK_STARTED:
//  193       // once on the network, time to go on to the identify state
//  194       if( zclEZModeState == EZMODE_STATE_JOINER )
//  195       {
//  196         // set local permit joining on locally only for joiners (openers turn it on across the network)
//  197         zcl_EZModePermitJoiningRequest( *zclEZModeRegisterData.pTaskID, NULL,
//  198                                        (byte)(EZMODE_TIME / 1000) ); // in seconds
//  199         zcl_SetEZModeState( EZMODE_STATE_IDENTIFYING );
//  200       }
//  201     break;
//  202 
//  203     // received identify query
//  204     case EZMODE_ACTION_IDENTIFY_QUERY:
//  205 
//  206       // targets just go to autoclose once they have been identified
//  207       if ( !zclEZModeInvokeData.initiator )
//  208       {
//  209         zcl_SetEZModeState( EZMODE_STATE_AUTOCLOSE );
//  210       }
//  211     break;
//  212 
//  213     // received identify query response
//  214     case EZMODE_ACTION_IDENTIFY_QUERY_RSP:
//  215 
//  216       if ( pData->pIdentifyQueryRsp->srcAddr->addr.shortAddr
//  217           != zcl_EZModeGetNwkAddr() )
//  218       {
//  219         // remember the node we found via identify query
//  220         zclEZModeQueryRspNwkAddr = pData->pIdentifyQueryRsp->srcAddr->addr.shortAddr;
//  221         zclEZModeQueryRspEP = pData->pIdentifyQueryRsp->srcAddr->endPoint;
//  222 
//  223         // initiate match descriptor request on the remote node
//  224         dstAddr.addrMode = Addr16Bit;
//  225         dstAddr.addr.shortAddr = zclEZModeQueryRspNwkAddr;
//  226         zcl_EZModeSendMatchDescReq( *zclEZModeRegisterData.pTaskID,
//  227                           &dstAddr,
//  228                           zclEZModeQueryRspNwkAddr,
//  229                           zclEZModeInvokeData.numActiveOutClusters,
//  230                           zclEZModeInvokeData.pActiveOutClusterIDs,
//  231                           zclEZModeInvokeData.numActiveInClusters,
//  232                           zclEZModeInvokeData.pActiveInClusterIDs );
//  233         zcl_SetEZModeState( EZMODE_STATE_WAITING_MATCHDESCRSP );
//  234       }
//  235     break;
//  236 
//  237     // received match descriptor response, see if active clusters match
//  238     case EZMODE_ACTION_MATCH_DESC_RSP:
//  239 
//  240       pMatchDescRsp = pData->pMatchDescRsp;
//  241       if ( ( pMatchDescRsp && pMatchDescRsp->status == ZSuccess ) && ( pMatchDescRsp->cnt>0 ) )
//  242       {
//  243         zclEZModeMatched = TRUE;
//  244 
//  245         dstAddr.addr.shortAddr = zclEZModeQueryRspNwkAddr;
//  246         dstAddr.addrMode = Addr16Bit;
//  247 
//  248         // bind each matching input cluster
//  249         if ( zclEZModeInvokeData.numActiveInClusters )
//  250         {
//  251           zcl_EZModeBindAddEntry( zclEZModeInvokeData.endpoint, &dstAddr, zclEZModeQueryRspEP,
//  252                         zclEZModeInvokeData.numActiveInClusters, zclEZModeInvokeData.pActiveInClusterIDs );
//  253         }
//  254 
//  255         // bind each matching output cluster
//  256         if ( zclEZModeInvokeData.numActiveOutClusters )
//  257         {
//  258           zcl_EZModeBindAddEntry( zclEZModeInvokeData.endpoint, &dstAddr, zclEZModeQueryRspEP,
//  259                         zclEZModeInvokeData.numActiveOutClusters, zclEZModeInvokeData.pActiveOutClusterIDs );
//  260         }
//  261       }
//  262 
//  263       // time to close (wait a bit before finishing, to allow for multiple initiators)
//  264       zcl_SetEZModeState( EZMODE_STATE_AUTOCLOSE );
//  265     break;
//  266 
//  267     // timed out of EZ-Mode
//  268     case EZMODE_ACTION_TIMED_OUT:
//  269       // timed out
//  270       if(zclEZModeState != EZMODE_STATE_READY)
//  271       {
//  272         zcl_SetEZModeError( EZMODE_ERR_TIMEDOUT );
//  273         zcl_SetEZModeState( EZMODE_STATE_FINISH );
//  274       }
//  275     break;
//  276   }   // switch ( action )
//  277 
//  278 }
//  279 
//  280 /*********************************************************************
//  281  * LOCAL VARIABLES
//  282  */
//  283 
//  284 
//  285 /*********************************************************************
//  286  * LOCAL FUNCTIONS
//  287  */
//  288 
//  289 /*********************************************************************
//  290  * @fn      zcl_SetEZModeState
//  291  *
//  292  * @brief   Move on to new state after a short wait.
//  293  *
//  294  * @param   none
//  295  *
//  296  * @return  none
//  297  */
//  298 static void zcl_SetEZModeState( zlcEZMode_State_t newState )
//  299 {
//  300   zclEZModeState = newState;
//  301   zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, 5 );
//  302 }
//  303 
//  304 /*********************************************************************
//  305  * @fn      zclSampleSw_SetEZModeError
//  306  *
//  307  * @brief   Called to set error code that will be reported on finish. Starts as EZMODE_ERR_SUCCESS.
//  308  *
//  309  * @param   none
//  310  *
//  311  * @return  none
//  312  */
//  313 static void zcl_SetEZModeError( uint8 errorCode )
//  314 {
//  315   zclEZModeErr = errorCode;
//  316 }
//  317 
//  318 /*********************************************************************
//  319  * @fn      zcl_ProcessEZMode
//  320  *
//  321  * @brief   Called when EZ-Mode changes state. See EZMODE_STATE_xxxx in zcl_ezmode.h
//  322  *
//  323  * @param   none
//  324  *
//  325  * @return  status
//  326  */
//  327 static void zcl_ProcessEZMode( void )
//  328 {
//  329   zAddrType_t dstAddr;
//  330   afAddrType_t afDstAddr;
//  331   zclEZMode_CBData_t cbData;
//  332 
//  333   dstAddr.addr.shortAddr = 0xfffc;        // all routers (for PermitJoin) devices
//  334   dstAddr.addrMode = AddrBroadcast;
//  335 
//  336   afDstAddr.addr.shortAddr = 0xffff;      // all devices (for IdentifyQuery)
//  337   afDstAddr.addrMode = afAddrBroadcast;
//  338   afDstAddr.endPoint = 0xff;
//  339 
//  340   switch(zclEZModeState)
//  341   {
//  342     // openers will broadcast permit joining
//  343     case EZMODE_STATE_OPENER:
//  344       zclEZModeOpener = 1;
//  345 
//  346       // enable joining both locally and over-the-air
//  347       zcl_EZModePermitJoiningRequest( *zclEZModeRegisterData.pTaskID, &dstAddr,
//  348                                      (byte)(EZMODE_TIME / 1000) );
//  349 
//  350       // then go to identifying state
//  351       zcl_SetEZModeState(EZMODE_STATE_IDENTIFYING);
//  352     break;
//  353 
//  354     // joiners will try to join the network, and if success will go to identifying state
//  355     case EZMODE_STATE_JOINER:
//  356       zclEZModeOpener = 0;
//  357       zcl_EZModeStartDevice(*zclEZModeRegisterData.pTaskID, 0);   // see ZDO_STATE_CHANGE in zclSampleSw_event_loop()
//  358     break;
//  359 
//  360     // go into identify state
//  361     case EZMODE_STATE_IDENTIFYING:
//  362 
//  363       // tell app to go into identify mode
//  364       if ( zclEZModeRegisterData.pfnNotifyCB )
//  365       {
//  366         (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, NULL );
//  367       }
//  368 
//  369       // initiators start looking for other nodes in identify mode
//  370       if ( zclEZModeInvokeData.initiator )
//  371       {
//  372         zcl_SetEZModeState ( EZMODE_STATE_WAITING_IDENTIFYQUERYRSP );
//  373       }
//  374     break;
//  375 
//  376     // timeout out with no query response, send another
//  377     case EZMODE_STATE_WAITING_IDENTIFYQUERYRSP:
//  378       // ZStatus_t zclGeneral_SendIdentifyQuery( uint8 srcEP, afAddrType_t *dstAddr, uint8 disableDefaultRsp, uint8 seqNum );
//  379       // NOTE: Ensure that Identify Cluster is enabled to use this function for EZ-Mode
//  380       zclGeneral_SendIdentifyQuery( zclEZModeInvokeData.endpoint, &afDstAddr, TRUE, (*zclEZModeRegisterData.pZclSeqNum)++ );
//  381 
//  382       // wait some time before sending out the next IdentifyQuery, will stop when we get a response
//  383       zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, EZMODE_IDQUERYTIME );
//  384       break;
//  385 
//  386     // waiting for simple descriptor response
//  387     case EZMODE_STATE_WAITING_MATCHDESCRSP:
//  388     break;
//  389 
//  390     // if waiting on autoclose, then we're done. Go to success.
//  391     case EZMODE_STATE_AUTOCLOSE:
//  392 
//  393       // special case: if 2 initators, we only fail if no match from either side
//  394       if( zclEZModeInvokeData.initiator && !zclEZModeMatched )
//  395       {
//  396         zcl_SetEZModeError ( EZMODE_ERR_NOMATCH );
//  397       }
//  398 
//  399       // if user specified callback, call on AutoClose
//  400       if ( zclEZModeRegisterData.pfnNotifyCB )
//  401       {
//  402         cbData.sAutoClose.err = zclEZModeErr;
//  403         (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, &cbData );
//  404       }
//  405 
//  406       // no longer will timeout, since cannot fail
//  407       zcl_EZModeStopTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.timeoutEvt );
//  408 
//  409       // wait a little to turn off identify mode, to give time for the other side to discover
//  410       // in case of complex devices (both target/initiator)
//  411       zcl_EZModeStartTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, EZMODE_AUTOCLOSETIME );
//  412 
//  413       // go to finish state after autoclose. Don't use zcl_SetEZModeState() because we don't want it to happen immediately
//  414       zclEZModeState = EZMODE_STATE_FINISH;
//  415     break;
//  416 
//  417     case EZMODE_STATE_FINISH:
//  418 
//  419       // no longer will timeout, since we're done
//  420       zcl_EZModeStopTimer( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.timeoutEvt );
//  421 
//  422       // if we opened the network, close it now (turn off joining)
//  423       if ( zclEZModeOpener )
//  424       {
//  425         zcl_EZModePermitJoiningRequest( *zclEZModeRegisterData.pTaskID, &dstAddr, 0 );
//  426       }
//  427 
//  428       // if user callback, inform them of the finish, which will also turn off identify
//  429       if ( zclEZModeRegisterData.pfnNotifyCB )
//  430       {
//  431         cbData.sFinish.err = zclEZModeErr;
//  432         cbData.sFinish.ep = zclEZModeQueryRspEP;
//  433         cbData.sFinish.nwkaddr = zclEZModeQueryRspNwkAddr;
//  434         (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, &cbData );
//  435       }
//  436 
//  437       // done, back to ready state
//  438       zclEZModeState = EZMODE_STATE_READY;
//  439     break;
//  440   }
//  441 }
//  442 
//  443 #if !defined ( ZCL_STANDALONE )
//  444 /*********************************************************************
//  445  * @fn      zcl_EZModeSendMatchDescReq
//  446  *
//  447  * @brief   Call to send a ZDP Match Descriptor Request
//  448  *
//  449  * @param   srcID - source task ID sending,
//  450  *          for ZCL_STANDALONE, use source endpoint
//  451  * @param   dstAddr - destination address
//  452  * @param   nwkAddr - network address of interest
//  453  * @param   NumInClusters - number of input clusters
//  454  * @param   InClusterList - input cluster ID list
//  455  * @param   NumOutClusters - number of output clusters
//  456  * @param   OutClusterList - output cluster ID list
//  457  *
//  458  * @return  afStatus_t
//  459  */
//  460 afStatus_t zcl_EZModeSendMatchDescReq( uint8 srcID,
//  461                                        zAddrType_t *dstAddr,
//  462                                        uint16 nwkAddr,
//  463                                        uint8  NumInClusters,
//  464                                        uint16 *InClusterList,
//  465                                        uint8  NumOutClusters,
//  466                                        uint16 *OutClusterList )
//  467 {
//  468   (void)srcID;
//  469   return ZDP_MatchDescReq( dstAddr,
//  470                            nwkAddr,
//  471                            ZCL_HA_PROFILE_ID,
//  472                            NumInClusters,
//  473                            InClusterList,
//  474                            NumOutClusters,
//  475                            OutClusterList,
//  476                            FALSE );
//  477 }
//  478 
//  479 /*********************************************************************
//  480  * @fn      zcl_EZModeStartTimer
//  481  *
//  482  * @brief   This function is called to start a timer to expire in n mSecs.
//  483  *          When the timer expires, call zcl_EZModeAction().
//  484  *
//  485  * @param   uint8 taskID - task id to set timer for
//  486  * @param   uint16 event_id - event to be notified with
//  487  * @param   uint32 timeout_value - in milliseconds.
//  488  *
//  489  * @return  SUCCESS, or NO_TIMER_AVAIL.
//  490  */
//  491 afStatus_t zcl_EZModeStartTimer( uint8 task_id, uint16 event_id,
//  492                                   uint32 timeout_value )
//  493 {
//  494   return osal_start_timerEx( task_id, event_id, timeout_value );
//  495 }
//  496 
//  497 /*********************************************************************
//  498  * @fn      zcl_EZModeStopTimer
//  499  *
//  500  * @brief   This function is called to cancel a timer.
//  501  *
//  502  * @param   uint8 taskID - task id to set timer for
//  503  * @param   uint16 event_id - event to be notified with
//  504  *
//  505  * @return  SUCCESS, or NO_TIMER_AVAIL.
//  506  */
//  507 afStatus_t zcl_EZModeStopTimer( uint8 task_id, uint16 event_id )
//  508 {
//  509   return osal_stop_timerEx( task_id, event_id );
//  510 }
//  511 
//  512 /*********************************************************************
//  513  * @fn      zcl_EZModePermitJoiningRequest
//  514  *
//  515  * @brief   Call to set the permit joining for device and network.
//  516  *
//  517  * @param   srcID - source task ID sending,
//  518  *          for ZCL_STANDALONE, use source endpoint
//  519  * @param   dstAddr - destination address of the message (short addr only),
//  520  *                    NULL to send to local device only.
//  521  * @param   duration - Permit duration
//  522  *
//  523  * @return  none
//  524  */
//  525 void zcl_EZModePermitJoiningRequest( uint8 srcID, zAddrType_t *dstAddr,
//  526                                     uint8 duration )
//  527 {
//  528   zAddrType_t tmpAddr;
//  529 
//  530   (void)srcID;
//  531 
//  532   tmpAddr.addrMode = Addr16Bit;
//  533 
//  534   if ( dstAddr == NULL )
//  535   {
//  536     tmpAddr.addr.shortAddr = NLME_GetShortAddr();
//  537   }
//  538   else
//  539   {
//  540     tmpAddr.addr.shortAddr = dstAddr->addr.shortAddr;
//  541   }
//  542 
//  543   // Trust Center significance is always true
//  544   ZDP_MgmtPermitJoinReq( &tmpAddr, duration, TRUE, FALSE );
//  545 }
//  546 
//  547 /*********************************************************************
//  548  * @fn      zcl_EZModeStartDevice
//  549  *
//  550  * @brief   Call to start a device joining.
//  551  *
//  552  * @param   srcID - source task ID sending,
//  553  *          for ZCL_STANDALONE, use source endpoint
//  554  * @param   startDelay - timeDelay to start device (in milliseconds)
//  555  *
//  556  * @return      none
//  557  */
//  558 void zcl_EZModeStartDevice( uint8 srcID, uint16 startDelay )
//  559 {
//  560   (void)srcID;
//  561   ZDOInitDevice( startDelay );
//  562 }
//  563 
//  564 /*********************************************************************
//  565  * @fn      zcl_EZModeBindAddEntry()
//  566  *
//  567  * @brief   This function is used to Add an entry to the binding table
//  568  *
//  569  * @param   srcEpInt - source endpoint
//  570  * @param   dstAddr - destination Address
//  571  * @param   dstEpInt - destination endpoint
//  572  * @param   numClusterIds - number of cluster Ids in the list
//  573  * @param   clusterIds - pointer to the Object ID list
//  574  *
//  575  * @return  pointer to binding table entry, NULL if not added
//  576  */
//  577 void zcl_EZModeBindAddEntry( uint8 srcEpInt,
//  578                              zAddrType_t *dstAddr, uint8 dstEpInt,
//  579                              uint8 numClusterIds, uint16 *clusterIds )
//  580 {
//  581   if ( pbindAddEntry )
//  582   {
//  583     if ( pbindAddEntry( srcEpInt, dstAddr, dstEpInt, numClusterIds, clusterIds ) )
//  584     {
//  585       ZDApp_NVUpdate();
//  586     }
//  587   }
//  588 }
//  589 
//  590 /*********************************************************************
//  591  * @fn      zcl_EZModeGetNwkAddr()
//  592  *
//  593  * @brief   This function is used to Add an entry to the binding table
//  594  *
//  595  *   NOTE: Do not call this function outside of zcl_ezmode.c.
//  596  *   NOTE2:  For ZCL_STANDALONE, this function needs to be implemented
//  597  *           elsewhere.
//  598  *
//  599  * @param       none
//  600  *
//  601  * @return  16 bit network address
//  602  */
//  603 uint16 zcl_EZModeGetNwkAddr( void )
//  604 {
//  605   return ( NLME_GetShortAddr() );
//  606 }
//  607 #endif // !ZCL_STANDALONE
//  608 
//  609 #endif // ZCL_EZMODE
// 
//
// 
//
//
//Errors: none
//Warnings: none
